{"changed":true,"filter":false,"title":"Flori.py","tooltip":"/Flori.py","value":"#from Main import *\n#IMPORT EXCHANGE\nfrom optibook.synchronous_client import Exchange\nimport time\n\nimport logging\nlogger = logging.getLogger('client')\nlogger.setLevel('ERROR')\n\nprint(\"Setup was successful.\")\nimport time\nimport pandas as pd\nimport os\nimport numpy as np\n\n#CONNECT TO EXCHANGE\ne = Exchange()\na = e.connect()\ninstrument_id = 'PHILIPS_A'\nbook = e.get_last_price_book('PHILIPS_A')\nprint(book.asks)\nprint(book.bids)\n\n\nprices = dict() # empty dict\n\nprint([price_vol.price for price_vol in book.asks])\nprint([price_vol.price for price_vol in book.bids])\n\ninstrument_id1 = 'PHILIPS_A'\ninstrument_id2 = 'PHILIPS_B'\nbooks = e.get_last_price_book(instrument_id)\n\ndef print_table(books):\n    print(\"bid | price | ask\")\n    for ask in books.asks:\n        print(f\"    | {round(ask.price,1)} | {ask.volume}\")\n    for bid in books.bids:\n        print(f\"{bid.volume} | {round(bid.price,1)} |      \")\n        \n        \nprint_table(books)\nprint_table(e.get_last_price_book(instrument_id2))\n\n\n\nimport heapq\n\ndef get_highest_profit(id1,id2):\n    # use heaps - max heap for bid price and min heap for ask price \n    # max heap for bid price - accross both books\n    book1 = e.get_last_price_book(id1)\n    book2 = e.get_last_price_book(id2)\n    #bids_heap_max = heapq._heapify_max([bid.price for bid in book1.bids] + [bid2.price for bid2 in book2.bids]) \n    #asks_heap_min = heapq.heapify([ask.price for ask in book1.asks] + [ask2.price for ask2 in book2.asks]) \n    max_profit = max([bid.price for bid in book1.bids] + [bid2.price for bid2 in book2.bids]) - min([ask.price for ask in book1.asks] + [ask2.price for ask2 in book2.asks])\n    if max_profit > 0:\n        return max_profit\n    else:\n        return -1 * max_profit\n\nprofit = get_highest_profit(instrument_id1, instrument_id2)\nprint(profit)\n\nprint('-------------------------------------functions from New Henry - could not import--------------------------------------------')\n\ndef record_market(n):\n    \n    bestBidsBookA = []\n    bestAsksBookB = []\n    times = []\n    count=0\n    \n    while(count<n):\n        time.sleep(1)\n        times.append(count)\n        bestBidsBookA.append(e.get_last_price_book('PHILIPS_A').bids[0].price)\n        bestAsksBookB.append(e.get_last_price_book('PHILIPS_B').asks[0].price)\n        count=count+1\n        #time.strftime(\"%H:%M:%S\",time.localtime())\n    dict1 = {'Time' : times, 'Best bid in A' : bestBidsBookA, 'Best ask in B' : bestAsksBookB}\n    df = pd.DataFrame(dict1)\n    return df\n\ndf= record_market(10)\n#print(df)\nprint(df['Best bid in A'])\nprint(df['Best ask in B'])\n#print(df['Best bid in A'].corr(df['Best ask in B']))\n\n\n    \n    \n\n\n    \n    \n    ","undoManager":{"mark":-2,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":1200,"scrollleft":0,"selection":{"start":{"row":8,"column":0},"end":{"row":8,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":74,"state":"start","mode":"ace/mode/python"}},"timestamp":1611456373016}