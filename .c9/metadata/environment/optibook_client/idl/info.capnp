{"changed":false,"filter":false,"title":"info.capnp","tooltip":"/optibook_client/idl/info.capnp","value":"@0xc1776f751066a792;\n\nusing Cxx = import \"/capnp/c++.capnp\";\n$Cxx.namespace(\"Idl\");\n\nusing Common = import \"common.capnp\";\n\nenum BookUpdateType {\n  price @0;\n  order @1;\n}\n\nstruct PriceBook {\n  instrumentId @0 :Text;\n  bids @1 :List(PriceVolume);\n  asks @2 :List(PriceVolume);\n\n  struct PriceVolume {\n    price @0 :Float64;\n\tvolume @1 :UInt32;\n  }\n}\n\nstruct InstrumentCreated {\n  instrumentId @0 :Text;\n  tickSize @1 :Float64;\n  extraInfo @2 :Text; # json\n}\n\nstruct InstrumentExpired {\n  instrumentId @0 :Text;\n  expirationValue @1 :Float64;\n}\n\nstruct InstrumentPaused {\n  instrumentId @0 :Text;\n}\n\nstruct InstrumentResumed {\n  instrumentId @0 :Text;\n}\n\n# Info server is special, because we don't use capnp RPC mechanism here\n# This is mostly because the info server needs to be fully optimized for\n# bulk broadcasting of messages to a lot of clients, which doesn't suit\n# capnproto's RPC well in terms of performance overhead\n\n# For info server we just have a raw tcp connection over which we transfer\n# messages of type Common.RawMessage\n# Each of the Common.RawMessage contains an anypointer that points to:\n# From Client to Server:\n# - Info.InfoSubscribeRequest\n# From Server to Client:\n# - Common.GenericReply\n# - Info.PriceBook\n# - Common.TradeTick\n# - Info.InstrumentCreated\n# - Info.InstrumentExpired\n# - Info.InstrumentPaused\n# - Info.InstrumentResumed\n# More messages may be added in the future\n\nstruct InfoSubscribeRequest {\n  requestId @0 :UInt32;\n  bookUpdateType @1 :BookUpdateType;\n  adminPassword @2 :Text;\n}\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":0,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1611461128752}